- 도큐먼트 지향 데이터 모델을 자세히 살펴 보고, MongoDB 에서 데이터가 어떻게 데이터베이스로, 컬렉션으로, 도큐먼트 단위로 구성되는지 알아 보자.

- 그 전에 MongoDB 와 함께 사용되는 스키마 설계 방법에 관해 알아보자.

- MongoDB 는 스키마를 강제하진 않지만, 데이터가 어떻게 저장되는지에 대한 내부 기준 정도는 있어야 하므로, RDBMS 의 스키마와 어떻게 다른지 알아보고, 일대다, 다대다 와 같이 개체 간의 관계가 어떻게 표현되는지 알아 보자.

---

## 4.1 스키마 설계 원리

- 데이터베이스 스키마 설계는 요구사항이 주어졌을 때 데이터에 대한 최적의 표현을 찾아내는 과정이다. 스키마 설계를 어떻게 하냐에 따라 애플리케이션의 기능과 성능이 결정된다. 그러므로 다음과 같은 항목이 고려야 된다.

1. 애플리케이션 액세스 패턴

- 애플리케이션의 요구사항이 무엇인지 정확히 파악할 필요가 있다. 읽기/쓰기 비율은 어떻게 되고, 쿼리는 키를 찾는 정도로 쉬운지 아니면 복잡한지, 집계는 필요한지, 데이터는 얼마나 저장되는지 파악해야 한다.

2. 데이터베이스에는 어떤 기능이 있는가

- MongoDB 는 기존 방식(RDBMS) 의 트랜잭션을 지원하지 않지만, 복잡한 도큐먼트의 내부 구조에 대해 수행할 수 있는 업데이트를 다양하게 지원한다.

3. PK와 UNIQUE KEY 를 어떻게 선정하는가

- 위 기준을 어떻게 선정하느냐에 따라 데이터를 접근하는 방식과 저장하는 방식에서 큰 차이를 만들어 낼 수 있다. MongoDB 에서 PK 를 선택하는 것은 어떤 값이 \_id 필드에 채워질 것인지 고르는 것을 뜻한다. 자동으로 생성되는 객체 id는 기본 설정으로 나쁘지 않지만, 모든 경우에 이상적인 것은 아니다. 여러 장비에 데이터를 샤딩하는 경우라면 이는 특히 중요한데, 특정 행이 저장될 곳을 결정하기 때문이다.

- 최적의 스키마 설계는 사용하는 데이터베이스에 대한 깊은 지식과 애플리케이션의 요구사항에 대한 현명한 판단 그리고 오랜 경험으로 부터 나오므로 새로운 것을 배울 때 스키마를 변경하는 것에 대해 두려움을 갖지 말도록 하자.

---

## 4.2 전자 상거래 데이터 모델 설계

- 스키마 설계에 익숙해지기 위해, 전자 상거래 데이터 모델을 설계해 보자. 전자상거래는 전적으로 RDBMS 에 속한 도메인이었는데, 이유는 전자상거래 사이트는 일반적으로 트랜잭션이 필요한데, 트랜잭션은 RDBMS 의 장점이다. 두 번째로 다양한 데이터 모델과 동적인 쿼리가 RDBMS 에 가장 적합한 것으로 최근까지 여겨졌기 때문이다.

- 많은 개발자들에게 데이터 모델(data model) 과 객체 매핑(object mapping) 은 떼어서 생각할 수 없는데, 이를 위해 자바의 하이버네이트(Hibernate) 등 ORM 라이브러리를 사용하기도 한다. MongoDB 에서는 객체-관계 매핑 툴에 대한 필요성이 상대적으로 낮은데, 도큐먼트가 이미 객체와 같은 표현이기 때문이다.

---

### 4.2.1 스키마 기본

- 상품과 카테고리는 전자상거래 사이트에서도 가장 기본적인 것이다. 정규화된 RDBMS 모델에서 상품은 많은 수의 테이블이 필요하다. 이름이나 SKU 같이 기본적인 상품 정보를 위한 테이블이 있어야 하고, 배송 정보나 가격 변동을 위한 테이블도 있어야 한다. 이러한 다중 테이블 스키마가 가능한 이유는 RDBMS 에서는 테이블을 조인할 수 있기 때문이다.

- MongoDB 에서는 상품을 모델링 하는 것이 좀 더 단순한데, 컬렉션에 대한 스키마가 필요하지 않으므로 어떤 상품 도큐먼트라도 상품이 필요로 하는 동적인 속성을 받아 들일 수 있다.

- 도큐먼트 내에 배열을 사용하면, RDBMS 에서 여러 개의 테이블로 표현되는 것이 MongoDB 에서는 하나의 컬렉션으로 줄어든다.

- 좀 더 구체적으로 예를 한번 살펴보자.

```javascript
db.products.insert({
  slug: "wheelbarrow-9092",
  sku: "9092",
  name: "Extra Large Wheelbarrow",
  description: "Heavy duty wheelbarrow...",
  details: {
    weight: 47,
    weight_units: "lbs",
    model_num: 4039283402,
    manufacturer: "Acme",
    color: "Green",
  },
  total_reviews: 4,
  average_review: 4.5,
  pricing: {
    retail: 589700,
    sale: 489700,
  },
  price_history: [
    {
      retail: 529700,
      sale: 429700,
      start: new Date(2010, 4, 1),
      end: new Date(2010, 4, 8),
    },
    {
      retail: 529700,
      sale: 529700,
      start: new Date(2010, 4, 9),
      end: new Date(2010, 4, 16),
    },
  ],
  primary_category: ObjectId("6a5b1476238d3b4dd5000048"),
  category_ids: [
    ObjectId("6a5b1476238d3b4dd5000048"),
    ObjectId("6a5b1476238d3b4dd5000049"),
  ],
  main_cst_id: ObjectId("6a5b1476238d3b4dd5000048"),
  tags: ["tools", "gardening", "soil"],
});
```

**고유한 슬러그**

- slug 필드 에는 "wheelbarrow-9092" 라는 값이 있다. 사용자 친화적인 고유 주소(permalinks) 는 종종 슬러그(slug) 로 불린다. 도큐먼트에 대해 URL 을 생성할 때는 슬러그 필드를 만들자. 고유 인덱스를 마들어서 해당 필드의 값이 빠른 쿼리 접근성을 갖는 동시에 고유성을 보장하도록 하자.

- 또한, 슬러그를 \_id 필드에 저장하여 PK 로 쓸 수 있다. 이번 예제는 그러지 않았다. 두 가지 모두 가능한 방법이라는 것만 알아두자.

```javascript
db.products.createIndex({ slug: 1 }, { unique: true });
```

- slug 에 대한 고유 인덱스를 생성했다면 중복된 값을 삽입했을 때 예외가 발생할 것이다. 이 경우 다른 슬러그로 삽입 연산을 재시도할 수 있다.

```javascript
WriteResult({
        "nInserted" : 0,
        "writeError" : {
                "code" : 11000,
                "errmsg" : "E11000 duplicate key error collection: test.products index: slug_1 dup key: { slug: \"wheelbarrow-9092\" }"
```

- 예외에 대한 감지와 처리는 나중에 알아보자.

---

**중첩 도큐먼트**

- 그 다음으로 나오는 것은 detail 키인데, 여러 가지 상품에 대한 자세한 정보를 갖는 서브도큐먼트를 가리킨다. 이미 존재하는 도큐먼트 내부에 또 다른 것들을 찾게 해준다는 점에서 \_id 필드와는 전혀 다른 것이다. 이 필드에는 무게와 무게의 단위, 제조사의 모델 번호가 명시된다.

- pricing 키는 소비자 가격과 세일 가격을 가지고 있는 객체를 가리키는데, 이처럼 같은 도큐먼트에 상품의 현재 가격과 과거의 가격을 저장할 수도 있다.

- price_history 는 가격의 변천사를 배열로 저장하고 있다. 도큐먼트의 복사본을 저장하는 것은 도큐먼트를 버전별로 관리하는 일반적인 기법이다.

- 다음으로 tags 는 상품에 대한 태그의 배열로 배열의 키에 대해 인덱스를 만들 수 있으므로 상품에 대한 관련 태그를 저장하고 동시에 효율적인 쿼리를 보장해 주는 가장 간단하고 좋은 방법이다.

---

**일대다 관계, 다대다 관계**

- 종종 다른 컬렉션에 있는 도큐먼트와 관계를 설정해야만 할 때가 있다.
  MongoDB 는 조인을 지원하지 않으므로 다대다 관계를 위해서는 다른 어떤 것이 필요하다. 객체 ID 를 가지고 있는 primary_category, category_ids 라는 필드는 카테고리 도큐먼트의 \_id 필드에 대한 레퍼런스이다.

**관계 구조**

- 카테고리 도큐먼트의 예를 insert 해 보자.

```javascript
db.categories.insert({
  _id: ObjectId("6a5b1476238d3b4dd5000048"),
  slug: "gardening-tools",
  name: "Gardening Tools",
  description: "Gardening gadgets galore!",
  parent_id: ObjectId("55804822812cb336b78728f9"),
  ancestors: [
    { name: "Home", _id: ObjectId("558048f0812cb336b78728fa"), slug: "home" },
    {
      name: "Outdoors",
      _id: ObjectId("55804822812cb336b78728f9"),
      slug: "outdoors",
    },
  ],
});
```

- 이 상품 "Gardening Tools" 는 이전 상품 카테고리에 category-ids 필드에 들어가 있다. 상품 도큐먼트의 category_ids 배열은 다대다 관계에 대한 모든 종류의 질의를 가능하게 한다. '가드닝 툴' 카테고리에 속해 있는 모든 상품에 대한 질의는 다음과 같이 할 수 있다.

```javascript
db.products.find({ category_ids: ObjectId("6a5b1476238d3b4dd5000048") });
```

- 상품(product) 변수가 다음과 같은 명령어로 정의가 되어 있다고 가정하자.

```javascript
product = db.product.findOne({ slug: "wheelbarrow-9092" });
```

- 어떤 상품이 속해 있는 모든 카테고리를 알기 위해서는 $in 연산자를 사용한다.

```javascript
db.categories.find({ _id: { $in: db.products["category_ids"] } });
```

- 위에서 예로 사용한 카테고리 도큐먼트에서 \_id, slug, name, description 필드의 의미는 명확하지만, ancestors 도큐먼트 배열은 그렇지 않을지도 모른다. 왜 이렇게 중복해서 저장할까?

- 카테고리는 항상 계층 구조로 인식되는데, 데이터베이스에서 그러한 계층 구조를 표현하는 방법으로 여러 가지가 있다.

- 위의 예에서는 'Home' 을 상품 카테고리로, 'Outdoors' 를 'Home' 의 하위 카테고리로 그리고 'Gardening Tools'를 'Outdoors' 의 하위 카테고리로 가정해 보자.

- MongoDB 가 조인을 지원하지 않으므로 각 자식 도큐먼트에서 조상 카테고리의 이름을 모두 가지고 있기로 한 것이다. 이렇게 할 경우 '가드닝 상품' 카테고리에 속한 상품에 대한 쿼리를 수행할 때 'Outdoors' 나 'Home' 과 같은 부모 카테고리를 불러오기 위해 추가적인 쿼리를 수행할 필요가 없다.

- 어떤 사람은 이러한 비정규화를 받아들일 수 없다고 생각할지도 모른다. 지금은 스키마를 가장 잘 결정하는 것이 이론적인 원리가 아니라 애플리케이션의 요구사항일 수도 있다는 가능성을 열어놓자. 다음 장에서 이 구조의 질의와 갱신의 예제를 보게되면, 이해할 수 있을 것이다.

---

### 4.2.2 사용자와 주문

- 사용자(users) 와 주문(order) 을 모델링하는 방법을 살펴보면 흔한 관계인 일대다 관계를 설명할 수 있다. 이 경우 사용자는 하나 이상의 주문을 가지고 있다. RDBMS 에서는 주문 테이블에서 외래 키를 사용할 것이다. 여기에서도 비슷한 방식을 사용하는데 다음을 살펴보자.

```javascript
db.orders.insert({
  _id: ObjectId("6a5b1476238d3b4dd5000048"),
  user_id: ObjectId("4c4b1476238d3b4dd5000001"),
  state: "CART",
  line_items: [
    {
      _id: ObjectId("4c4b1476238d3b4dd5003981"),
      sku: "9092",
      name: "Extra Large Wheelbarrow",
      quantity: 1,
      pricing: {
        retail: 5897,
        sale: 4897,
      },
    },
    {
      _id: ObjectId("4c4b1476238d3b4dd5003982"),
      sku: "10027",
      name: "Rubberized Work Glove, Black",
      quantity: 2,
      pricing: {
        retail: 1499,
        sale: 1299,
      },
    },
  ],
  shipping_address: {
    street: "588 5th Street",
    city: "Brooklyn",
    state: "NY",
    zip: 11215,
  },
  sub_total: 6194,
});
```

- 이 주문 도큐먼트의 두 번째 속성인 user_id 는 사용자의 \_id 값을 가지고 있다. 샘플플 사용자를 가리키는데, 이렇게 모델링하면 관계의 어느 쪽에 대해서도 쿼리를 쉽게 할 수 있다. 어느 한 사용자가 주문한 모든 주문을 찾는 것은 간단하다.

```javascript
db.orders.find({ user_id: user["_id"] });
```

- 특정 주문에 대한 사용자의 도큐먼트를 얻기 위한 쿼리도 간단하다.

```javascript
db.users.findOne({ _id: order["user_id"] });
```

---

**도큐먼트에 대한 생각**

- 주문 도큐먼트의 특징을 살펴보자. 일반적으로 객체를 전체적으로 표현하기 위해서 도큐먼트 데이터 모델이 제공하는 다양한 표현을 사용한다. 주문 도큐먼트가 아이템과 배송 주소를 모두 가지고 있으며, 정규화된 관계 모델에서 이런 속성은 별도의 테이블로 표현된다. 주문 아이템은 서브도큐먼트의 배열로 이루어져 있는데, 각각의 쇼핑 카트에 있는 한 상품을 나타낸다. 배송 주소는 주소 필드를 가지고 있는 하나의 객체를 가리키고 있다.

- 이러한 표현은 여러 장점이 있다.

  1.  사람이 이해하기 쉽다. 아이템, 배송 주소, 지불 정보를 포함한 주문의 전반적인 개념이 하나의 개체 안에 들어가 있다. 데이터베이스에 대해 질의할 떄 간단한 쿼리로 주문 객체 전체를 반환할 수 있다.

  2.  또한, 상품이 구매된 후에는 주문 아이템들이 주문 도큐먼트 내에서 효과적으로 둉결된다. 마지막으로, 주문 도큐먼트에 대한 질의와 수정이 용이하다.

- 사용자 도큐먼트는 주소 도큐먼트의 리스트와 함께 지불 방식 도큐먼트의 리스트를 저장하는데 이 역시 비슷한 패턴을 보여 준다. 도큐먼트의 초상위 레벨에서 어떤 사용자 모델에도 공통적인 기본 속성을 저장한다. 상품의 slug 필드와 같이 사용자 이름 필드가 고유 인덱스를 갖는 것이 현명하다.

```javascript
db.users.insert({
  _id: ObjectId("4c4b1476238d3b4dd5000001"),
  username: "kbanker",
  email: "kylebanker@gmail.com",
  first_name: "Kyle",
  last_name: "Banker",
  hashed_password: "bd1cfa194c3a603e7186780824b04419",
  address: [
    {
      name: "home",
      street: "588 5th Street",
      city: "Brooklyn",
      state: "NY",
      zip: 11215,
    },
    {
      name: "work",
      street: "1 E. 23rd Street",
      city: "New York",
      state: "NY",
      zip: 10010,
    },
  ],
  payment_methods: [
    {
      name: "VISA",
      payment_token: "43f6ba1dfda6b8106dc7",
    },
  ],
});
```

---

### 4.2.3 상품평

- 상품평을 마지막으로 살펴보고 샘플 데이터 모델 설계를 마쳐보자. 각 상품은 많은 상품평을 가질 수 있고, product_id 를 각각의 상품평에 저장함으로써 관계를 만들어 낼 수 있다.

```javascript
db.users.insert({
  _id: ObjectId("4c4b1476238d3b4dd5000041"),
  product_id: ObjectId("4c4b1476238d3b4dd5003981"),
  date: new Date(2010, 5, 7),
  title: "Amazing",
  text: "Has a squeaky wheel, but the still a darn good wheelbarrow.",
  rating: 4,
  user_id: ObjectId("4c4b1476238d3b4dd5000042"),
  username: "dgreenthumb",
  helpful_votes: 3,
  voter_ids: [
    ObjectId("4c4b1476238d3b4dd5000033"),
    ObjectId("7a4f0376238d3b4dd5000003"),
    ObjectId("92c21476238d3b4dd5000032"),
  ],
});
```

- 대부분의 속성들은 읨가 자명하다. 리뷰한 날짜, 제목, 텍스트와 사용자에 의해 주어진 평점과 사용자의 ID 를 저장한다. 사용자 이름까지 정하는 것은 이상하게 생각할 수 있다. 왜냐하면 RDBMS 에서는 users 테이블과 조인을 해서 사용자 이름을 알 수 있다.

- MongoDB 에서는 조인이 없으므로 두 가지 방법 중 하나를 써야 하는데, 각 리뷰마다 사용자 컬렉션에 대해 질의하거나 비정규화를 해야 한다. 사용자 이름은 거의 바뀌지 않아서 모든 리뷰마다 질의를 하는 것은 불필요한 일일 것이므로 정규화보다는 질의 속도를 최적화하는 것을 선택하였다.

- 상품명 도큐먼트에 추천수를 저장한 점도 주목할 만한데, 사용자가 상품평에 대해 추천할 수 있는 기능은 흔하다. 이 도큐먼트에는 추천한 사용자의 객체 ID 를 배열로 저장하는데, 이것은 사용자가 하나의 상품평에 대해 한 번 이상 추천하는 것을 막을 수 있다. 추천수도 저장하는데, 이를 이용해 추천수로 상품평을 정렬할 수도 있다. 이는 매우 유용한데 **MongoDB 가 도큐먼트 내의 배열의 크기를 질의하는 것은 허용하지 않기 때문이다.** 추천 배열의 크기가 helpful_votes 필드 내에 저장되어 있다면 추천수로 상품평을 정렬하는 질의는 매우 쉬워진다.

- 이것으로 기본적인 전자상거래 데이터 모델을 다루었다. 서뷰도큐먼트, 배열, 일데대 그리고 다대다 관계와 함꼐 스키마의 기본과 더불어 질의를 단순화하기 위한 툴로서 비정규화를 사용하는 방법을 살펴보았다. MongoB 데이터 모델을 처음으로 살펴본 것이라면 이 모델의 유용성에 대해 곰곰히 생각해 볼 때이며, 과연 이렇게 하는 것이 타당한지 의문이 생길 수 있는데 걱정하지 않아도 된다. 이 모든 것이 어떻게 돌아가는지 다음 두장에서 살펴보자.
