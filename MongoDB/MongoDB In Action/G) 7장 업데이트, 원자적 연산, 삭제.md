# 7장 업데이트, 원자적 연산, 삭제

- 데이터베이스를 업데이트하는 것은 기존의 도큐먼트에 쓰기를 하는 것

- MongoDB 에서 업데이트를 할 때, 비정규화된 방식으로 모델된 구조가 어떻게 이용되는지 자세하게 고찰해 보자.

- 그 과정에서 생겨나는 동시성 문제, 새로운 업데이트 연산자, 원자성( 다른 작업이 방해하지 않음을 보장한 상태에서 도큐먼트를 검색 및 업데이트하는 MongoDB 속성)에 대해 알아보자.

---

## 7.1 도큐먼트 업데이트

- MongoDB 에서 업데이트흐를 하려면 두 가지 방법을 사용 가능

  1. 도큐먼트 전체를 대치하든지

  2. 도큐먼트 내의 특정 필드를 수정하든지

### 7.1.1 대체에 의한 수정

- 전체 도큐먼트를 대치하기 위해서는 도큐먼트에 대한 쿼리 결과를 클라이언트 사이드에서 수정을 하고, 수정된 도큐먼트로 업데이트 명령을 내리게 된다.

```javascript
let user_id = ObjectId("4c4b1476238d3b4dd5003981");
let doc = db.collection("users").findOne({ _id: user_id });
doc["email"] = "mognodb-user@mongodb.com";
print("updateting " + user_id);
db.users.update({ _id: user_id }, doc);
```

> 사용자의 \_id 로 도큐먼트를 찾고, email 속성을 수정한 다음, 수정된 도큐먼트를 update 메서드의 매개변수로 넘겨 주었다.
> 전체 도큐먼트를 대치하므로, 마지막 쓰기 연산이 최종적으로 저장 된다.

### 7.1.2 연산자에 의한 수정

```javascript
let user_id = ObjectId("4c4b1476238d3b4dd5003981");
db.collection("users").update(
  { _id: user_id },
  { $set: { email: "mongodb-user@mongodb.com" } }
);
```

- $set 연산자를 사용하여 email 필드를 수정하였다.

---

### 7.1.3, 7.1.4 두 방법의 비교, 결정: 대치 vs 연산자

- 타깃 방식이 도큐먼트를 원자적으로 업데이트 하는데 적합하다. 만약 도큐먼트를 읽고 쓸 때 변경이 발생하면 문제가 생길 수 있음. 원자적으로 수행할 수 있는 유일한 방법은 낙관적 잠금(optimistic locking) 을 이용하는 것이다.

> 낙관적 잠금?

```
현실적으로 데이터 갱신시 경합이 발생하지 않을 것이라고 낙관적으로 보고 잠금을 거는 기법, 예로 회원정보에 대한 갱신은 보통 해당 회원에 의해서 이루어지므로 동시에 여러 요청이 발생할 가능성이 낮다. 따라서 동시에 수정이 이루어진 경우를 감지해서 예외를 발생시켜도 실제로 예외가 발생할 가능성이 낮다고 낙관적으로 보는 것이다. 엄밀한 의미에서보면 잠금이라기 보다는 충돌감지에 가깝다.
MongoDB 에서 낙관적 잠금은 업데이트를 하려고 할 떄 업데이트 시 타임스탬프를 이용해서 동시 페이지 수정요청이 들어오는 경우, 최종 것만 업데이트 되는 것.
```

- 연산자 방식이 수정할 도큐먼트를 가져오기 위해 서버에 먼저 요청할 필요가 없으며, 업데이트를 지정하는 도큐먼트의 크기가 일반적으로 작다. 이로 인해 업데이트는 데이터를 직렬화하고 전송하는 데 소요되는 시간이 적다.

---

## 7.2 전자상거래 업데이트

### 7.2.1 상품과 카테고리

- 타깃(연산자) 방식이 실제로 어떻게 사용되는지 살펴보도록 하자.

**상품의 평점 평균**

```javascript
let product_id = ObjectId("4c4b1476238d3b4dd5003981");
let count = 0;
let total = 0;
db.collection("reviews")
  .find({ product_id: product_id }, { rating: 4 })
  .forEach(function (review) {
    total += review.rating;
    count++;
  });

let average = total / count;
db.collection("products").update(
  { _id: product_id },
  { $set: { total_reviews: count, average_review: average } }
);
```

- ObjectId 를 하드코딩하지 않게 미리 찾아 올 수 있다.

```javascript
let product_id = db.collection("products").findOne({ sku: "9092" }, { _id: 1 });
```

```javascript
db.collection("products").update(
  { _id: product_id },
  {
    $set: {
      average_review: average,
      ratings_total: total,
    },
    $inc: {
      total_reviews: 1,
    },
  }
);
```

**카테고리 계층 구조**

- 대부분의 데이터베이스에서는 카테고리 계층 구조를 쉽게 표현할 수 있는 방법이 없다. MongoDB의 경우에도 도큐먼트 구조가 도움이 되긴 하나 마찬 가지이다.

- 도큐먼트는 각 카테고리가 조상 카테고리의 리스트를 가지고 있으므로 읽기에 최적화되어 있다.

```javascript
let generate_ancestors = function (_id, parent_id) {
  let ancestor_list = [];
  let cursor = db.collection("categories").find({ _id: parent_id });
  while (cursor.size() > 0) {
    let parent = cursor.next();
    ancestor_list.push(parent);
    let parent_id = parent.parent_id;
    cursor = db.collection("categories").find({ _id: parent_id });
  }
  db.collection("categories").update(
    { _id: _id },
    { $set: { ancestors: ancestor_list } }
  );
};
```

> 루트 노드에 도달할 떄까지 계층 구소를 거슬러 올라가 parent_id 속성을 연달아 쿼리하여, 조상 리스트를 구하는 것이다. 이렇게 해서 조상들의 순서가 있는 리스트를 구하고, 그 결과를 ancestor_list 에 저장한다. 마지막으로 $set 을 사용해서 카테고리의 ancestor 속성에 저장한다.

Home
|
Outdoors
| | | |
Tools Seedlings Planters Lawn care

- 이 구조에서 'Gardening' 이라는 카테고리를 'Home 카테고리 아래에 새로 추가한다고 하면 다음과 같이 할 수 있다.

```javascript
let parent_id = ObjectId("8b87fb1476238d3b4dd50003");
let category = {
    parent_id: parent_id,
    slug: 'gardening',
    name: 'Gardening',
    description: 'All gardening implements, tools, sedds, and soil."
}
db.collection('categories').save(cateogry);
generate_ancestors(category._id, parent_id)
```

Home
| |
Outdoors Gardening
| | | |
Tools Seedlings Planters Lawn care

- save() 는 생성된 ID를 원본 도큐먼트에 저장한다. ID 는 generate_ancestors() 호출에서 사용된다.

- 'Outdoors' 카테고리를 'Gardening' 카테고리 아래로 옮기려고 한다면 어떻게 해야할까? 여러 카테고리에 대해서 조상 리스트를 변경해야 하므로 복잡할 가능성이 많다. 'Outdoors' 카테고리의 parent_id 의 값을 'Gardening' 의 \_id 값으로 변경하는 것으로 시작할 것이다.

```javascript
db.collection("categories").update(
  { _id: outdoors_id },
  { $set: { parent_id: gardening_id } }
);
```

- 'Outdoors' 카테고리를 옮겼으므로 'Outdoors' 의 모든 자손 노드들은 유효하지 않은 조상 리스트를 갖게 된다. 그러므로 Outdoors 를 조상 카테고리로 가지고 있는 모든 카테고리를 찾은 다음, 카테고리들의 조상 리스트를 재계산하여 수정할 수 있다. MongoDB 의 배열에 대한 쿼리로 이것을 쉽게 할 수 있다.

```javascript
db.collection("categories")
  .find({ "ancestors.id": outdoors_id })
  .forEach(function (category) {
    generate_ancestors(category._id, outdoors_id);
  });
```

- 하지만 이제 카테고리 이름을 변경해야 한다면 어떻게 해야 할까? 'Outdoors' 를 'The Great Outdoors' 로 수정하려 한다면 다른 카테고리의 조상 카테고리 리스트에 있는 모든 'Outdoors' 를 'The Greate Outdoors' 로 변경해야 한다. 이 부분에서 비정규화를 하면 이런 문제점이 나타나지 하고 생각할 수도 있다. 하지만 조상 리스트를 계산할 필요 없이 이 업데이트를 수행할 수 있다.

```javascript
let doc = db.collection("categories").findOne({ _id: outdoors_id });
doc.name = "The Greate Outdoors";
db.collection("categories").update({ _id: outdoors_id }, doc);
db.collection("categories").update(
  { "ancestors._id": outdoors_id },
  { $set: { "ancestors.$": doc } },
  { multi: true }
);
```

> 'Outdoors' 도큐먼트를 찾아서 name 속성을 롴러 도큐먼트에서 바꿔 주고, 대치방식으로 업데이트
> 그리고 나서 수정된 'Outdoors' 도큐먼트를 이용해서 모든 조상 리스트에 나타나는 'Outdoors' 를 바꿔 준다. multi 매개변수는 셀렉터와 일치하는 모든 도큐먼트에 업데이트가 적용되도록 다중 업데이트가 가능하고, multi 매개변수가 없는 경우 첫 번째로 일치하는 도큐먼트에만 영향을 미친다. 조상 리스트에 'Outdoors' 가 나타나는 모든 카테고리를 업데이트하길 원하므로 다중 업데이트를 사용하면 된다.

> 위에서 ancestor.$ 의 $이 위치 연산자인데, 쿼리 셀렉터와 일치하는 배열 인덱스를 그 자신으로 대치해 업데이트를 가능하게 한다.

```javascript
db.collection("users").update(
  {
    _id: ObjectId("4c4b1476238db4dd5000001"),
    "addresses.name": "work",
  },
  { $set: { "adresses.$.street": "155 E 31st St." } }
);
```

- 배열 내에서 각 서브도큐먼트를 업데이트를 할 필요가 있는 경우에는 위치 연산자를 사용하여 업데이트 하도록 하자.
